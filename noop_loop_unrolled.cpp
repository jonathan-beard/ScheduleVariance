#include <sys/types.h>
#include <unistd.h>

#include "system_query.h"
#include "calibrate.hpp"
#include "process.hpp"
#include "gatekeeper.hpp"
#include "noop_loop_unrolled.hpp"

#define LOAD_LENGTH 40

NoOpLoopUnrolled::Data::Data() : Load::Data(), 
                                 noop_count( 0 ),
                                 frequency( 0 ),
                                 cycles_start( 0 ),
                                 cycles_end( 0 ),
                                 diff( 0 ),
                                 service_time( 0.0 )
{
   char name[ LOAD_LENGTH ] = "noop_unrolled\0";
   for( int i = 0; i < LOAD_LENGTH; i++ )
   {
      load_name[i] = name[i];
   }
}

NoOpLoopUnrolled::Data::Data(uint64_t noopCount,
                             uint64_t freq,
                             uint64_t cyclesStart,
                             uint64_t cyclesEnd,
                             double   service_time,
                             uint64_t delta ) :  
                              Load::Data(), 
                              noop_count( noopCount ),
                              frequency( freq ),
                              cycles_start( cyclesStart ),
                              cycles_end( cyclesEnd ),
                              diff( delta ),
                              service_time( service_time )
{
   char name[ LOAD_LENGTH ] = "noop_unrolled\0";
   for( int i = 0; i < LOAD_LENGTH; i++ )
   {
      load_name[i] = name[i];
   }
}
      
NoOpLoopUnrolled::Data::Data( const Data &d ) : Load::Data()
{
   noop_count = d.noop_count;
   frequency = d.frequency;
   cycles_start = d.cycles_start;
   cycles_end = d.cycles_end;
   diff = d.diff;
   service_time = d.service_time;
   for( int i = 0; i < LOAD_LENGTH; i++ )
   {
      load_name[i] = d.load_name[i];
   }
}

void
NoOpLoopUnrolled::Data::PrintHeader( std::ostream &stream )
{
   stream << "Load, ServiceTime, Frequency, NoopCount, CyclesStart, CyclesEnd, Delta";
}

void
NoOpLoopUnrolled::Data::PrintData( std::ostream &stream, Data &d )
{
   stream << d.load_name << "," << d.service_time << "," << d.frequency 
      << "," << d.noop_count;
   stream << "," << d.cycles_start << "," << d.cycles_end << ",";
   stream << d.diff;
}

NoOpLoopUnrolled::NoOpLoopUnrolled( CmdArgs &args ) : Load( args ),
                                                      seconds( 0.0 ),
                                                      service_time( 1.0 )
{
   frequency = getStatedCPUFrequency();
#include "noop_loop_unrolled_load_seconds.hpp"
   /* defined in above include */
   seconds = expectedSeconds;
   cmd_args.addOption( new Option< double >( service_time,
                                             "-mu",
                                             "Service rate for load" ) );
}

NoOpLoopUnrolled::~NoOpLoopUnrolled()
{
   /* nothing really to do */
}

void 
NoOpLoopUnrolled::RunLoad( Process &p, GateKeeper &g, int64_t i )
{
      g.WaitForGate( "Running" );
      /* A bit hacky but it'll work */
#include "noop_loop_unrolled_load.cpp"         
      g.WaitForGate( "Storing" );
      /**
       * Note: theNoopCount, cylcesbefore, cyclesafter, diff are 
       * defined in the autogenerated load (noop_loop_unrolled_load.cpp) 
       * which is generated by gen_noop_load.pl during compilation.
       */
      NoOpLoopUnrolled::Data d( theNoopCount /* # of noops in loop */,
                        frequency    /* what it says */,
                        cyclesbefore /* # cycles read before loop */,
                        cyclesafter  /* # cycles read after loop */,
                        service_time /* calibrated nominal service rate */,
                        diff         /* delta between before, after */ );
      p.SetData( (void*) &d );
      g.WaitForGate( "ReadyToStart" );
      g.ResetGate( "Running" );
      g.ResetGate( "Storing" );
      g.ResetGate( "ReadyToStart" );
}

bool 
NoOpLoopUnrolled::AllSet()
{
   /* check to see if we need calibration */
   if( seconds != service_time )
   {
      /* need to call calibrate here */
      Calibrate( service_time, cmd_args.getOriginalArguments() );
      /* won't return from this one, however
       * some compilers require a return here */
      return( false );
   }
   return( true );
}

std::ostream&
NoOpLoopUnrolled::PrintHeader( std::ostream &stream )
{
   NoOpLoopUnrolled::Data::PrintHeader( stream );
   return( stream );
}

std::ostream&
NoOpLoopUnrolled::PrintData( std::ostream &stream, void *d )
{
   NoOpLoopUnrolled::Data *d_ptr( reinterpret_cast< 
                                    NoOpLoopUnrolled::Data* >( d ) );
   NoOpLoopUnrolled::Data::PrintData( stream, *d_ptr );                               
   return( stream );
}
